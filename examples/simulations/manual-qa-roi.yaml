name: Manual Quality Assurance ROI Analysis
category: Quality Assurance
description: Analyze the cost-benefit of manual QA testing vs automated alternatives, modeling bug prevention value and testing overhead
version: 1.0.0
tags: [qa, quality, testing, software, risk]

parameters:
  - key: teamSize
    label: Development Team Size
    type: number
    default: 8
    min: 2
    max: 50
    step: 1
    description: Number of developers on the team

  - key: qaEngineers
    label: QA Engineers
    type: number
    default: 2
    min: 1
    max: 10
    step: 1
    description: Number of dedicated QA engineers

  - key: qaEngineerSalary
    label: QA Engineer Annual Salary ($)
    type: number
    default: 95000
    min: 60000
    max: 150000
    step: 5000
    description: Annual salary per QA engineer

  - key: developerSalary
    label: Developer Annual Salary ($)
    type: number
    default: 120000
    min: 80000
    max: 200000
    step: 5000
    description: Annual salary per developer

  - key: releaseFrequency
    label: Releases Per Year
    type: number
    default: 24
    min: 4
    max: 100
    step: 2
    description: Number of software releases per year

  - key: bugRateWithQA
    label: Bugs Per Release (With QA)
    type: number
    default: 2
    min: 0.5
    max: 10
    step: 0.5
    description: Average bugs that reach production with manual QA

  - key: bugRateWithoutQA
    label: Bugs Per Release (Without QA)
    type: number
    default: 8
    min: 3
    max: 25
    step: 1
    description: Average bugs that would reach production without manual QA

  - key: criticalBugPercentage
    label: Critical Bug Rate (%)
    type: number
    default: 15
    min: 5
    max: 40
    step: 5
    description: Percentage of bugs that are critical/high-impact

  - key: avgBugFixTime
    label: Average Bug Fix Time (Hours)
    type: number
    default: 6
    min: 2
    max: 16
    step: 1
    description: Average developer hours to fix a production bug

  - key: criticalBugMultiplier
    label: Critical Bug Cost Multiplier
    type: number
    default: 5
    min: 2
    max: 15
    step: 1
    description: How much more expensive critical bugs are to fix

  - key: customerImpactCost
    label: Customer Impact Cost Per Bug ($)
    type: number
    default: 2500
    min: 500
    max: 10000
    step: 500
    description: Average customer impact cost (support, churn, reputation)

  - key: qaToolingCost
    label: Annual QA Tooling Cost ($)
    type: number
    default: 15000
    min: 5000
    max: 50000
    step: 2500
    description: Annual cost for QA tools and infrastructure

  - key: testCycleTime
    label: QA Test Cycle Time (Days)
    type: number
    default: 3
    min: 1
    max: 10
    step: 1
    description: Average days for QA testing cycle per release

outputs:
  - key: annualQACost
    label: Annual QA Cost ($)
    description: Total annual cost of QA team and tooling

  - key: bugsPreventedPerYear
    label: Bugs Prevented Per Year
    description: Number of bugs prevented by manual QA annually

  - key: bugFixCostSavings
    label: Bug Fix Cost Savings ($)
    description: Annual savings from preventing bugs (developer time)

  - key: customerImpactSavings
    label: Customer Impact Savings ($)
    description: Annual savings from reduced customer impact

  - key: totalAnnualSavings
    label: Total Annual Savings ($)
    description: Total annual value provided by QA

  - key: netBenefit
    label: Net Annual Benefit ($)
    description: Annual savings minus QA costs

  - key: roi
    label: ROI Percentage
    description: Return on investment of QA team

  - key: timeToMarketDelay
    label: Time-to-Market Delay (Days/Year)
    description: Annual delay in releases due to QA cycles

simulation:
  logic: |
    // Calculate annual QA costs
    const annualQACost = (qaEngineers * qaEngineerSalary) + qaToolingCost;
    
    // Calculate bugs prevented per year with uncertainty
    const basePreventionRate = bugRateWithoutQA - bugRateWithQA;
    const qaEffectiveness = 0.7 + (random() * 0.5); // QA effectiveness varies 70-120%
    const bugsPreventedPerYear = Math.max(0, basePreventionRate * releaseFrequency * qaEffectiveness);
    
    // Calculate critical vs normal bug distribution
    const criticalBugsPrevented = bugsPreventedPerYear * (criticalBugPercentage / 100);
    const normalBugsPrevented = bugsPreventedPerYear - criticalBugsPrevented;
    
    // Calculate bug fix cost savings (developer time)
    const hourlyDeveloperCost = developerSalary / 2080; // ~40 hours/week * 52 weeks
    const normalBugFixCost = normalBugsPrevented * avgBugFixTime * hourlyDeveloperCost;
    const criticalBugFixCost = criticalBugsPrevented * avgBugFixTime * criticalBugMultiplier * hourlyDeveloperCost;
    const bugFixCostSavings = normalBugFixCost + criticalBugFixCost;
    
    // Calculate customer impact savings with variance
    const customerImpactVariance = 0.6 + (random() * 0.8); // Customer impact varies significantly
    const customerImpactSavings = bugsPreventedPerYear * customerImpactCost * customerImpactVariance;
    
    // Calculate total value and ROI
    const totalAnnualSavings = bugFixCostSavings + customerImpactSavings;
    const netBenefit = totalAnnualSavings - annualQACost;
    const roi = annualQACost > 0 ? (netBenefit / annualQACost) * 100 : 0;
    
    // Calculate time-to-market impact
    const timeToMarketDelay = releaseFrequency * testCycleTime;
    
    return {
      annualQACost: Math.round(annualQACost),
      bugsPreventedPerYear: Math.round(bugsPreventedPerYear * 10) / 10,
      bugFixCostSavings: Math.round(bugFixCostSavings),
      customerImpactSavings: Math.round(customerImpactSavings),
      totalAnnualSavings: Math.round(totalAnnualSavings),
      netBenefit: Math.round(netBenefit),
      roi: Math.round(roi * 10) / 10,
      timeToMarketDelay: Math.round(timeToMarketDelay)
    };