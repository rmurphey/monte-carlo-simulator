name: Software Project Estimation
category: Software Development
description: Comprehensive software development project estimation with team scaling, technical complexity modeling, and delivery timeline analysis
version: 2.0.0
tags: [software-development, project-estimation, team-scaling, delivery-planning]

parameters:
  - key: annualRecurringRevenue
    label: Company ARR ($)
    type: number
    default: 8000000
    min: 500000
    max: 500000000
    step: 250000
    description: Company ARR for development budget allocation

  - key: developmentBudgetPercent
    label: Development Budget (% of ARR)
    type: number
    default: 25.0
    min: 10.0
    max: 40.0
    step: 1.0
    description: Engineering budget as percentage of ARR (typical: 20-30%)

  - key: projectScope
    label: Project Scope
    type: select
    default: major-feature
    options: [minor-feature, major-feature, new-product, platform-rewrite, enterprise-integration]
    description: Scale and complexity of the software project

  - key: technicalComplexity
    label: Technical Complexity
    type: select
    default: moderate
    options: [low, moderate, high, cutting-edge]
    description: Technical difficulty and innovation requirements

  - key: teamExperience
    label: Team Experience Level
    type: select
    default: mixed
    options: [junior-heavy, mixed, senior-heavy, expert-team]
    description: Overall experience level of the development team

  - key: architecturalRisk
    label: Architectural Risk
    type: select
    default: moderate
    options: [low-risk, moderate, high-risk, experimental]
    description: Risk level of architectural decisions and dependencies

  - key: qualityRequirement
    label: Quality Requirements
    type: select
    default: production
    options: [prototype, alpha, production, enterprise-grade]
    description: Required quality and reliability standards

  - key: timeConstraint
    label: Timeline Pressure
    type: select
    default: normal
    options: [flexible, normal, aggressive, critical-deadline]
    description: Time pressure and delivery urgency

groups:
  - name: Budget & Resources
    description: ARR-based budget allocation and project scope
    parameters: [annualRecurringRevenue, developmentBudgetPercent, projectScope]
    
  - name: Technical Factors
    description: Complexity and architectural considerations
    parameters: [technicalComplexity, architecturalRisk, qualityRequirement]
    
  - name: Team & Timeline
    description: Team composition and delivery constraints
    parameters: [teamExperience, timeConstraint]

outputs:
  - key: estimatedDuration
    label: Estimated Duration (weeks)
    description: Total project duration from start to delivery

  - key: teamSize
    label: Optimal Team Size
    description: Recommended number of developers for optimal delivery

  - key: totalCost
    label: Total Project Cost ($)
    description: Complete project cost including all development resources

  - key: featuresDelivered
    label: Features Delivered per Week
    description: Average feature delivery velocity

  - key: riskAdjustedTimeline
    label: Risk-Adjusted Timeline (weeks)
    description: Timeline with risk buffers and contingency planning

  - key: qualityAssuranceWeeks
    label: QA & Testing Duration (weeks)
    description: Time required for testing and quality assurance

  - key: coordinationOverhead
    label: Coordination Overhead (%)
    description: Percentage of effort spent on team coordination

  - key: deliveryConfidence
    label: Delivery Confidence (%)
    description: Statistical confidence in meeting timeline and budget

simulation:
  logic: |
    // Calculate available development budget
    const annualDevelopmentBudget = annualRecurringRevenue * (developmentBudgetPercent / 100)
    const averageDeveloperCost = 175000  // Fully-loaded annual cost
    const maxTeamFromBudget = Math.floor(annualDevelopmentBudget / averageDeveloperCost)
    
    // Project scope complexity factors
    const scopeFactors = {
      'minor-feature': { 
        baseWeeks: 3, 
        complexity: 0.8, 
        teamSize: 2, 
        riskMultiplier: 1.1 
      },
      'major-feature': { 
        baseWeeks: 12, 
        complexity: 1.0, 
        teamSize: 5, 
        riskMultiplier: 1.3 
      },
      'new-product': { 
        baseWeeks: 24, 
        complexity: 1.4, 
        teamSize: 8, 
        riskMultiplier: 1.6 
      },
      'platform-rewrite': { 
        baseWeeks: 52, 
        complexity: 1.8, 
        teamSize: 12, 
        riskMultiplier: 2.2 
      },
      'enterprise-integration': { 
        baseWeeks: 36, 
        complexity: 1.5, 
        teamSize: 10, 
        riskMultiplier: 1.9 
      }
    }
    
    // Technical complexity impact
    const complexityMultipliers = {
      'low': { development: 0.8, testing: 0.9, coordination: 0.9 },
      'moderate': { development: 1.0, testing: 1.0, coordination: 1.0 },
      'high': { development: 1.4, testing: 1.3, coordination: 1.2 },
      'cutting-edge': { development: 2.0, testing: 1.8, coordination: 1.5 }
    }
    
    // Team experience efficiency
    const experienceFactors = {
      'junior-heavy': { efficiency: 0.6, rampUp: 4, coordination: 1.3 },
      'mixed': { efficiency: 0.8, rampUp: 2, coordination: 1.1 },
      'senior-heavy': { efficiency: 1.1, rampUp: 1, coordination: 0.9 },
      'expert-team': { efficiency: 1.3, rampUp: 0.5, coordination: 0.8 }
    }
    
    // Architectural risk impact
    const riskFactors = {
      'low-risk': { schedule: 1.0, budget: 1.0, confidence: 0.85 },
      'moderate': { schedule: 1.2, budget: 1.1, confidence: 0.75 },
      'high-risk': { schedule: 1.5, budget: 1.3, confidence: 0.60 },
      'experimental': { schedule: 2.0, budget: 1.6, confidence: 0.45 }
    }
    
    // Quality requirement factors
    const qualityFactors = {
      'prototype': { testing: 0.3, documentation: 0.2, qa: 0.5 },
      'alpha': { testing: 0.6, documentation: 0.4, qa: 0.7 },
      'production': { testing: 1.0, documentation: 0.8, qa: 1.0 },
      'enterprise-grade': { testing: 1.4, documentation: 1.2, qa: 1.3 }
    }
    
    // Timeline pressure impact
    const timelineFactors = {
      'flexible': { pressure: 0.9, quality: 1.1, scope: 1.0 },
      'normal': { pressure: 1.0, quality: 1.0, scope: 1.0 },
      'aggressive': { pressure: 1.3, quality: 0.9, scope: 0.95 },
      'critical-deadline': { pressure: 1.8, quality: 0.8, scope: 0.85 }
    }
    
    // Extract factors for current configuration
    const scope = scopeFactors[projectScope]
    const complexity = complexityMultipliers[technicalComplexity]
    const experience = experienceFactors[teamExperience]
    const risk = riskFactors[architecturalRisk]
    const quality = qualityFactors[qualityRequirement]
    const timeline = timelineFactors[timeConstraint]
    
    // Team size calculation with coordination overhead
    const idealTeamSize = Math.min(scope.teamSize, maxTeamFromBudget)
    const coordinationOverhead = idealTeamSize > 1 ? 
                                Math.min(0.15 + (idealTeamSize - 1) * 0.03, 0.40) : 0
    
    // Base development time calculation
    const baseDevelopmentWeeks = scope.baseWeeks * 
                               scope.complexity * 
                               complexity.development * 
                               (1 / experience.efficiency) * 
                               risk.schedule *
                               timeline.pressure *
                               (0.8 + random() * 0.4)  // Execution variance
    
    // Team scaling efficiency (Brooks' Law consideration)
    const teamEfficiency = idealTeamSize <= 3 ? 1.0 : 
                          idealTeamSize <= 7 ? 0.9 : 
                          idealTeamSize <= 12 ? 0.8 : 0.65
    
    const adjustedDevelopmentWeeks = baseDevelopmentWeeks / (teamEfficiency * idealTeamSize)
    
    // QA and testing duration
    const testingWeeks = adjustedDevelopmentWeeks * 
                        quality.testing * 
                        complexity.testing * 
                        timeline.quality *
                        (0.9 + random() * 0.2)
    
    // Total duration including ramp-up
    const rampUpWeeks = experience.rampUp * (idealTeamSize / 3)
    const estimatedDuration = adjustedDevelopmentWeeks + testingWeeks + rampUpWeeks
    
    // Risk-adjusted timeline with buffers
    const riskBuffer = scope.riskMultiplier * risk.schedule * (0.8 + random() * 0.4)
    const riskAdjustedTimeline = estimatedDuration * riskBuffer
    
    // Cost calculations
    const weeklyCost = idealTeamSize * (averageDeveloperCost / 52)
    const totalCost = riskAdjustedTimeline * weeklyCost * risk.budget
    
    // Feature delivery velocity
    const baseFeatureCount = scope.baseWeeks / 2  // Assume 1 feature per 2 weeks baseline
    const featuresDelivered = (baseFeatureCount * timeline.scope) / estimatedDuration
    
    // Delivery confidence calculation
    const baseConfidence = risk.confidence
    const experienceBonus = (experience.efficiency - 0.6) * 0.2  // Experience improves confidence
    const teamSizeAdjustment = idealTeamSize <= 7 ? 0.1 : -0.1   // Smaller teams more predictable
    const deliveryConfidence = Math.min(0.95, Math.max(0.30, 
                               baseConfidence + experienceBonus + teamSizeAdjustment))
    
    return {
      estimatedDuration: round(estimatedDuration * 10) / 10,
      teamSize: idealTeamSize,
      totalCost: round(totalCost),
      featuresDelivered: round(featuresDelivered * 100) / 100,
      riskAdjustedTimeline: round(riskAdjustedTimeline * 10) / 10,
      qualityAssuranceWeeks: round(testingWeeks * 10) / 10,
      coordinationOverhead: round(coordinationOverhead * 100),
      deliveryConfidence: round(deliveryConfidence * 100)
    }